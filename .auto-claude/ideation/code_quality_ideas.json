{
  "code_quality": [
    {
      "id": "cq-001",
      "type": "code_quality",
      "title": "Extract duplicated API proxy route logic into reusable utility",
      "description": "The API route files (epicrisis/route.ts, translate/route.ts, transcribe/route.ts) contain nearly identical patterns: fetch to backend, handle response, catch errors with `error: any`. This violates DRY principle and makes maintenance harder.",
      "rationale": "Code duplication across 4 API routes leads to inconsistent error handling when changes are made and increases maintenance burden. Centralizing this logic would reduce code from ~100 lines to ~40 lines and ensure consistent behavior.",
      "category": "duplication",
      "severity": "minor",
      "affectedFiles": [
        "app/api/chat/route.ts",
        "app/api/epicrisis/route.ts",
        "app/api/translate/route.ts",
        "app/api/transcribe/route.ts"
      ],
      "currentState": "4 API routes with identical try-catch patterns, error handling, and backend proxy logic. Each route has 25-50 lines of similar code.",
      "proposedChange": "Create lib/api/proxy-helper.ts with a createBackendProxy() utility function that handles the common pattern. Routes would become 5-10 lines each calling the shared utility.",
      "codeExample": "// Current (repeated in 4 files):\ntry {\n  const response = await fetch(backendUrl, {...});\n  if (!response.ok) {\n    return NextResponse.json({ error: `Backend Error` }, { status: response.status });\n  }\n  return NextResponse.json(data);\n} catch (error: any) {\n  return NextResponse.json({ error: error.message }, { status: 500 });\n}\n\n// Proposed:\nimport { proxyToBackend } from '@/lib/api/proxy-helper';\nexport const POST = proxyToBackend('/api/v1/ai/epicrisis');",
      "bestPractice": "DRY Principle - centralize repeated patterns into reusable utilities",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": 80,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": null
    },
    {
      "id": "cq-002",
      "type": "code_quality",
      "title": "Eliminate 'any' type usage in TypeScript files",
      "description": "Multiple files use 'any' type assertions, particularly in error handling (`catch (error: any)`) and data mapping (`data.map((item: any)`). This undermines TypeScript's type safety benefits.",
      "rationale": "Using 'any' bypasses type checking, leading to potential runtime errors that TypeScript should catch. Proper error types and data interfaces improve code reliability and developer experience.",
      "category": "types",
      "severity": "minor",
      "affectedFiles": [
        "app/api/chat/route.ts",
        "app/api/epicrisis/route.ts",
        "app/api/translate/route.ts",
        "app/api/transcribe/route.ts",
        "components/dashboard/chat-interface.tsx",
        "components/dashboard/history-interface.tsx",
        "mdx-components.tsx"
      ],
      "currentState": "7 files contain explicit 'any' type usage. Error catch blocks use `error: any`, Citation interface has `metadata?: any`, and history mapping uses `item: any`.",
      "proposedChange": "1. Replace `error: any` with `error: unknown` and proper type guards.\n2. Define proper interfaces for API responses in lib/types/api.ts.\n3. Create typed Citation metadata interface.\n4. Add proper typing for history API response.",
      "codeExample": "// Current:\ncatch (error: any) {\n  return NextResponse.json({ error: error.message }, { status: 500 });\n}\n\n// Proposed:\ncatch (error: unknown) {\n  const message = error instanceof Error ? error.message : 'Unknown error';\n  return NextResponse.json({ error: message }, { status: 500 });\n}\n\n// Current:\nmetadata?: any;\n\n// Proposed:\ninterface CitationMetadata {\n  year?: string;\n  authors?: string | string[];\n  journal?: string;\n}",
      "bestPractice": "TypeScript strict mode compliance - avoid 'any' to maintain type safety",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": ["Create lib/types/api.ts for shared API types"]
    },
    {
      "id": "cq-003",
      "type": "code_quality",
      "title": "Create reusable TwoColumnEditor component for generator interfaces",
      "description": "EpicrisisGenerator and TranslatorInterface share nearly identical two-column layout patterns with input on left, output on right, similar card styling, copy button functionality, and loading states. This structural duplication could be abstracted.",
      "rationale": "Both components use the same grid layout (grid-cols-1 lg:grid-cols-2), card styling, output display with copy functionality, and loading indicators. Abstracting this reduces code and ensures consistent UX across generator features.",
      "category": "duplication",
      "severity": "suggestion",
      "affectedFiles": [
        "components/dashboard/epicrisis-generator.tsx",
        "components/dashboard/translator-interface.tsx"
      ],
      "currentState": "Two components with ~240 combined lines sharing similar layout structure, copy button, loading states, and output display patterns.",
      "proposedChange": "Create components/dashboard/shared/two-column-editor.tsx with configurable input/output columns, built-in copy functionality, and loading states. Reduce each generator to ~50 lines focused on business logic.",
      "codeExample": "// Proposed shared component:\nexport function TwoColumnEditor({\n  inputTitle,\n  inputPlaceholder,\n  outputTitle,\n  inputContent,\n  outputContent,\n  isLoading,\n  onSubmit,\n  submitLabel,\n  inputIcon,\n  inputActions\n}: TwoColumnEditorProps) {\n  // Shared layout, copy button, loading states\n}\n\n// Usage in EpicrisisGenerator:\n<TwoColumnEditor\n  inputTitle=\"Vstupní data\"\n  outputTitle=\"Výstupní zpráva\"\n  onSubmit={handleGenerate}\n  submitLabel=\"Generovat Epikrízu\"\n/>",
      "bestPractice": "Component composition - extract shared UI patterns into reusable components",
      "metrics": {
        "lineCount": 242,
        "complexity": null,
        "duplicateLines": 60,
        "testCoverage": null
      },
      "estimatedEffort": "medium",
      "breakingChange": false,
      "prerequisites": null
    },
    {
      "id": "cq-004",
      "type": "code_quality",
      "title": "Add unit tests for critical business logic",
      "description": "The project has no application-level test files. Critical functionality like auth actions, API routes, and form validation have no test coverage, making refactoring risky and bug detection harder.",
      "rationale": "Without tests, every code change carries risk of regression. Auth flows, API proxy logic, and form validation are critical paths that should have test coverage to ensure reliability for medical professionals.",
      "category": "testing",
      "severity": "major",
      "affectedFiles": [
        "lib/auth-actions.ts",
        "lib/auth-context.tsx",
        "app/api/chat/route.ts",
        "app/api/epicrisis/route.ts",
        "components/auth/login-form.tsx",
        "components/auth/register-form.tsx"
      ],
      "currentState": "No test files found in app/, components/, or lib/ directories. Only node_modules contain tests from dependencies.",
      "proposedChange": "1. Set up Vitest or Jest testing framework with React Testing Library.\n2. Add unit tests for lib/auth-actions.ts (signIn, signUp, signOut).\n3. Add integration tests for API routes with mocked fetch.\n4. Add component tests for auth forms with user interaction scenarios.\n5. Create __tests__ folders alongside source files.",
      "codeExample": "// lib/__tests__/auth-actions.test.ts\nimport { signIn, signUp } from '../auth-actions';\nimport { createClient } from '@/lib/supabase/server';\n\njest.mock('@/lib/supabase/server');\n\ndescribe('auth-actions', () => {\n  describe('signIn', () => {\n    it('redirects to dashboard on success', async () => {\n      // Test implementation\n    });\n    it('returns error message on failure', async () => {\n      // Test implementation\n    });\n  });\n});",
      "bestPractice": "Test-Driven Development - critical paths should have automated test coverage",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": 0
      },
      "estimatedEffort": "large",
      "breakingChange": false,
      "prerequisites": ["Configure testing framework (Vitest or Jest)", "Set up test utilities and mocks"]
    },
    {
      "id": "cq-005",
      "type": "code_quality",
      "title": "Extract shared form state management into custom hook",
      "description": "Auth forms (login, register, forgot-password, reset-password) share common patterns for loading state, error handling, and form submission. This could be consolidated into a reusable useFormSubmit hook.",
      "rationale": "All 4 auth forms implement the same pattern: isLoading state, error state, try-catch with setError, finally setIsLoading(false). Extracting this reduces boilerplate and ensures consistent error handling.",
      "category": "duplication",
      "severity": "minor",
      "affectedFiles": [
        "components/auth/login-form.tsx",
        "components/auth/register-form.tsx",
        "components/auth/forgot-password-form.tsx",
        "components/auth/reset-password-form.tsx"
      ],
      "currentState": "4 form components each implementing ~15 lines of identical state management: useState for isLoading/error, try-catch pattern, finally block to reset loading.",
      "proposedChange": "Create hooks/useFormSubmit.ts that encapsulates loading state, error handling, and submission wrapper. Forms would use the hook and focus only on their specific validation and action logic.",
      "codeExample": "// hooks/useFormSubmit.ts\nexport function useFormSubmit<T>() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState('');\n\n  const handleSubmit = async (\n    action: () => Promise<{ error?: string } | void>\n  ) => {\n    setError('');\n    setIsLoading(true);\n    try {\n      const result = await action();\n      if (result?.error) setError(result.error);\n    } catch (err) {\n      setError('Něco se pokazilo. Zkuste to znovu.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return { isLoading, error, handleSubmit, setError };\n}\n\n// Usage in LoginForm:\nconst { isLoading, error, handleSubmit } = useFormSubmit();\nconst onSubmit = (e) => {\n  e.preventDefault();\n  handleSubmit(() => signIn(email, password));\n};",
      "bestPractice": "Custom hooks - encapsulate reusable stateful logic for cleaner components",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": 60,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": ["Create hooks/ directory if not exists"]
    }
  ],
  "metadata": {
    "filesAnalyzed": 65,
    "largeFilesFound": 0,
    "duplicateBlocksFound": 4,
    "lintingConfigured": true,
    "testsPresent": false,
    "generatedAt": "2025-12-25T14:15:00Z"
  }
}
