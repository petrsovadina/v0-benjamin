{
  "performance_optimizations": [
    {
      "id": "perf-001",
      "type": "performance_optimizations",
      "title": "Add React.memo and useCallback to prevent unnecessary re-renders in chat",
      "description": "The ChatInterface component has no memoization. Every time a new message is added, ALL existing ChatMessage components re-render. Additionally, inline arrow functions like `onClick={() => handleSendMessage()}` create new function references on every render.",
      "rationale": "The grep search shows ZERO usage of React.memo, useMemo, or useCallback across all components. ChatMessage component re-renders for every message in the list when a new message arrives. With long conversations (10+ messages), this causes noticeable lag. The inline onClick handlers in chat-interface.tsx, vzp-search-interface.tsx, and others create new function instances on every render, breaking React's shallow comparison.",
      "category": "rendering",
      "impact": "high",
      "affectedAreas": [
        "components/dashboard/chat-interface.tsx",
        "components/dashboard/chat-message.tsx",
        "components/dashboard/history-interface.tsx",
        "components/dashboard/vzp-search-interface.tsx"
      ],
      "currentMetric": "All chat messages re-render on every state update (O(n) renders per message)",
      "expectedImprovement": "~70% reduction in component renders during chat, smoother scrolling and input responsiveness",
      "implementation": "1. Wrap ChatMessage with React.memo()\n2. Extract inline onClick handlers to useCallback hooks\n3. Memoize message array transformations with useMemo\n4. Apply React.memo to VzpResultCard and HistoryItem cards\n5. Use useCallback for handleSendMessage, handleKeyDown, handleSearch",
      "tradeoffs": "Slight increase in code complexity; requires understanding of dependency arrays",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-002",
      "type": "performance_optimizations",
      "title": "Enable Next.js Image Optimization and configure proper image handling",
      "description": "The next.config.mjs has `images: { unoptimized: true }` which completely disables Next.js image optimization. This means images are served at full size without WebP conversion, lazy loading optimization, or responsive sizing.",
      "rationale": "Next.js Image component provides automatic WebP conversion (30-50% smaller files), lazy loading, responsive sizing, and blur placeholders. With optimization disabled, users download full-size images regardless of viewport, significantly impacting LCP and TTI on slower connections. Czech MedAI targets medical professionals who may access it on various devices and network conditions.",
      "category": "bundle_size",
      "impact": "high",
      "affectedAreas": [
        "next.config.mjs",
        "components/landing/hero-section.tsx",
        "components/landing/testimonials-section.tsx",
        "app/layout.tsx"
      ],
      "currentMetric": "All images served unoptimized (full size, original format)",
      "expectedImprovement": "30-50% reduction in image payload, ~1-2s improvement in LCP on 3G connections",
      "implementation": "1. Remove or set `images: { unoptimized: false }` in next.config.mjs\n2. Configure image domains if using external sources\n3. Replace <img> tags with Next.js <Image> component\n4. Add proper width/height or fill props\n5. Consider adding blur placeholders for above-the-fold images",
      "tradeoffs": "Requires specifying image dimensions; external images need domain configuration",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-003",
      "type": "performance_optimizations",
      "title": "Implement Supabase client singleton and request caching",
      "description": "The `createClient()` function is called multiple times per component lifecycle - once in AuthContext and again in each API call (chat-interface.tsx, history-interface.tsx). Each call creates a new browser client instance. Additionally, there's no caching for API responses like query history.",
      "rationale": "Found 10+ calls to `createClient()` across components, with some components calling it multiple times (AuthContext creates one, then ChatInterface creates another for getSession). This wastes memory and network resources. The history API endpoint is called on every mount without caching, even if data hasn't changed. API responses like drug searches could benefit from short-term caching.",
      "category": "network",
      "impact": "medium",
      "affectedAreas": [
        "lib/supabase/client.ts",
        "lib/auth-context.tsx",
        "components/dashboard/chat-interface.tsx",
        "components/dashboard/history-interface.tsx"
      ],
      "currentMetric": "New Supabase client created per API call; no response caching",
      "expectedImprovement": "~50% reduction in client initialization overhead; ~30% fewer API calls with caching",
      "implementation": "1. Modify createClient to use singleton pattern with memoization\n2. Export useSupabaseClient hook that reuses the singleton\n3. Add React Query or SWR for API response caching\n4. Implement stale-while-revalidate for history endpoint\n5. Add 60-second cache for VZP drug search results",
      "tradeoffs": "Added dependency on caching library; need to handle cache invalidation on auth changes",
      "estimatedEffort": "medium"
    },
    {
      "id": "perf-004",
      "type": "performance_optimizations",
      "title": "Add AbortController for fetch requests to prevent memory leaks",
      "description": "API calls in ChatInterface, HistoryInterface, and VzpSearchInterface don't use AbortController. If the user navigates away or component unmounts while a request is in-flight, the request continues and tries to update unmounted component state.",
      "rationale": "The chat API call can take several seconds (AI response generation). If a user navigates away during loading, the fetch continues, and upon completion attempts `setMessages()` on an unmounted component. This causes React warnings and memory leaks. This is especially problematic for the streaming endpoint when implemented.",
      "category": "memory",
      "impact": "medium",
      "affectedAreas": [
        "components/dashboard/chat-interface.tsx",
        "components/dashboard/history-interface.tsx",
        "components/dashboard/vzp-search-interface.tsx",
        "components/dashboard/epicrisis-generator.tsx",
        "components/dashboard/translator-interface.tsx"
      ],
      "currentMetric": "Fetch requests continue after component unmount, causing memory leaks",
      "expectedImprovement": "Eliminates memory leaks from orphaned requests; cleaner component lifecycle",
      "implementation": "1. Create useAbortController custom hook\n2. Add AbortController.signal to all fetch calls\n3. Call controller.abort() in useEffect cleanup\n4. Handle AbortError gracefully in catch blocks\n5. Consider using react-query which handles this automatically",
      "tradeoffs": "Slightly more verbose fetch code; need to handle AbortError separately from real errors",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-005",
      "type": "performance_optimizations",
      "title": "Implement debounced search for VZP and history filtering",
      "description": "The history search filter in HistoryInterface runs `filteredHistory` computation on every keystroke. The VZP search doesn't debounce - users might trigger multiple API calls while typing quickly. Both cause unnecessary processing and potential API spam.",
      "rationale": "HistoryInterface's `filteredHistory` recalculates on every character typed in the search box (line 72-76). With 100+ history items, this becomes noticeable. VZP search triggers on Enter key, but quick tip buttons have no debounce. Adding debouncing would reduce unnecessary API calls and improve perceived responsiveness.",
      "category": "runtime",
      "impact": "low",
      "affectedAreas": [
        "components/dashboard/history-interface.tsx",
        "components/dashboard/vzp-search-interface.tsx"
      ],
      "currentMetric": "Filter runs on every keystroke; no debounce on search triggers",
      "expectedImprovement": "Smoother typing experience; ~40% fewer filter computations",
      "implementation": "1. Add useDeferredValue for search query in React 19\n2. Or implement useDebounce hook with 300ms delay\n3. Wrap filteredHistory computation in useMemo with debounced query dependency\n4. Add debounce to VZP search for automatic search-as-you-type feature",
      "tradeoffs": "Slight delay before filter results appear (300ms); requires React 19 or custom debounce hook",
      "estimatedEffort": "trivial"
    }
  ],
  "metadata": {
    "totalBundleSize": "Estimated 2-3MB based on dependencies (recharts, nextra, 20+ radix-ui packages)",
    "largestDependencies": ["nextra", "nextra-theme-docs", "recharts", "react-dom", "@supabase/supabase-js"],
    "filesAnalyzed": 45,
    "potentialSavings": "~40% reduction in re-renders, ~1-2s LCP improvement, elimination of memory leaks",
    "generatedAt": "2025-12-25T14:15:00Z",
    "analysisNotes": [
      "No React.memo/useMemo/useCallback usage found in any component",
      "Image optimization completely disabled in next.config.mjs",
      "Multiple Supabase client instantiations per request",
      "No AbortController usage for fetch requests",
      "Inline arrow functions in onClick handlers throughout codebase"
    ]
  }
}
