{
  "file_path": "backend/data_processing/embeddings/run_embeddings.py",
  "main_branch_history": [],
  "task_views": {
    "001-complete-guidelines-rag-pdf-import": {
      "task_id": "001-complete-guidelines-rag-pdf-import",
      "branch_point": {
        "commit_hash": "d092d181e511c0ef7a36dcfd2dfe3f083cbae73e",
        "content": "",
        "timestamp": "2025-12-25T01:35:52.079046"
      },
      "worktree_state": {
        "content": "import asyncio\nimport logging\nfrom backend.data_processing.utils.supabase_client import SupabaseSingleton\nfrom backend.data_processing.embeddings.embedding_generator import EmbeddingGenerator\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def generate_drug_embeddings():\n    supabase = SupabaseSingleton.get_client()\n    generator = EmbeddingGenerator()\n    \n    # 1. Fetch drugs without embeddings (or all if we want to refresh)\n    # For now, let's fetch those with empty embedding. \n    # Note: postgres vector IS NULL check\n    \n    # Supabase-py doesn't easily support IS NULL filter in select without RPC or raw SQL?\n    # We can fetch all and filter in python, or use a filter.\n    # Actually .is_(\"embedding\", \"null\") should work.\n    \n    logger.info(\"Fetching drugs without embeddings...\")\n    try:\n        response = supabase.table(\"drugs\").select(\"id, sukl_code, name, active_substance, spc_indications\").is_(\"embedding\", \"null\").execute()\n        drugs = response.data\n    except Exception as e:\n        logger.error(f\"Error fetching drugs: {e}\")\n        return\n\n    total = len(drugs)\n    logger.info(f\"Found {total} drugs to process.\")\n    \n    if total == 0:\n        return\n\n    batch_size = 50\n    \n    for i in range(0, total, batch_size):\n        batch = drugs[i : i + batch_size]\n        texts = []\n        ids = []\n        \n        for drug in batch:\n            # Create a text representation for embedding\n            # \"Name: ... Active Substance: ... SPC Indications: ...\"\n            text = f\"Name: {drug.get('name', '')}. Active Substance: {drug.get('active_substance', '')}.\"\n            if drug.get('spc_indications'):\n                text += f\" Indications: {drug.get('spc_indications')}\"\n                \n            texts.append(text)\n            ids.append(drug['id'])\n            \n        logger.info(f\"Generating embeddings for batch {i//batch_size + 1}...\")\n        embeddings = generator.generate_embeddings(texts)\n        \n        if not embeddings:\n            logger.warning(\"No embeddings generated for this batch.\")\n            continue\n            \n        # Update DB\n        updates = []\n        for j, emb in enumerate(embeddings):\n            updates.append({\n                \"id\": ids[j],\n                \"sukl_code\": batch[j][\"sukl_code\"], # Include sukl_code to prevent NOT NULL violation if interpreted as insert\n                \"embedding\": emb\n            })\n            \n        try:\n            # Explicitly specify on_conflict on primary key 'id' to ensure update\n            supabase.table(\"drugs\").upsert(updates, on_conflict=\"id\").execute()\n            logger.info(f\"Updated {len(updates)} drugs with embeddings.\")\n        except Exception as e:\n            logger.error(f\"Error updating DB: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(generate_drug_embeddings())\n",
        "last_modified": "2025-12-25T21:22:14.886748"
      },
      "task_intent": {
        "title": "001-complete-guidelines-rag-pdf-import",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T01:36:13.063430",
  "last_updated": "2025-12-25T01:36:13.076497"
}