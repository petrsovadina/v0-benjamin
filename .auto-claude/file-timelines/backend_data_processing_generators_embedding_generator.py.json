{
  "file_path": "backend/data_processing/generators/embedding_generator.py",
  "main_branch_history": [],
  "task_views": {
    "001-complete-guidelines-rag-pdf-import": {
      "task_id": "001-complete-guidelines-rag-pdf-import",
      "branch_point": {
        "commit_hash": "d092d181e511c0ef7a36dcfd2dfe3f083cbae73e",
        "content": "",
        "timestamp": "2025-12-25T01:35:52.079046"
      },
      "worktree_state": {
        "content": "import openai\nfrom typing import List, Dict, Any\nimport logging\nimport os\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nlogger = logging.getLogger(__name__)\n\nclass EmbeddingGenerator:\n    \"\"\"\n    Generates embeddings for drugs using OpenAI API.\n    \"\"\"\n    def __init__(self, model: str = \"text-embedding-ada-002\"):\n        self.model = model\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        if api_key:\n            self.client = openai.Client(api_key=api_key)\n        else:\n            self.client = None\n            logger.warning(\"OPENAI_API_KEY not found. Embeddings will fail if requested.\")\n        \n    def create_search_text(self, drug: Dict[str, Any], atc_name: str = \"\") -> str:\n        \"\"\"\n        Constructs the text to be embedded.\n        Includes name, strength, form, substances, ATC info.\n        \"\"\"\n        parts = [\n            f\"L\u00e9\u010div\u00fd p\u0159\u00edpravek: {drug.get('name', '')}\",\n            f\"S\u00edla: {drug.get('strength', '')}\" if drug.get('strength') else \"\",\n            f\"Forma: {drug.get('form', '')}\" if drug.get('form') else \"\",\n            f\"L\u00e9\u010div\u00e9 l\u00e1tky: {drug.get('active_substances', '')}\" if drug.get('active_substances') else \"\",\n            f\"ATC: {drug.get('atc_code', '')} - {atc_name}\" if atc_name else f\"ATC: {drug.get('atc_code', '')}\",\n            f\"Cesta: {drug.get('route', '')}\" if drug.get('route') else \"\"\n        ]\n        return \" | \".join([p for p in parts if p])\n\n    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))\n    def generate_embeddings(self, texts: List[str]) -> List[List[float]]:\n        \"\"\"\n        Generate embeddings for a list of texts in batches.\n        \"\"\"\n        if not self.client:\n            logger.warning(\"OpenAI client not initialized. Returning None for embeddings.\")\n            return [None] * len(texts)\n\n        if not texts:\n            return []\n\n        embeddings_list = []\n        try:\n            # OpenAI API handles batching, but we can also batch here if needed\n            response = self.client.embeddings.create(\n                input=texts,\n                model=self.model\n            )\n            data = response.data\n            # Ensure order is preserved\n            embeddings_list = [item.embedding for item in data]\n        except Exception as e:\n            logger.error(f\"Error generating embeddings: {e}\")\n            # Return None for failed items to keep length consistent matching input\n            return [None] * len(texts)\n            \n        return embeddings_list\n\n    async def generate_embeddings_async(self, texts: List[str]) -> List[List[float]]:\n        \"\"\"\n        Async wrapper for embedding generation (using sync client in thread or async client if available).\n        For simplicity, using blocking call here as we batch heavily.\n        \"\"\"\n        return self.generate_embeddings(texts)\n",
        "last_modified": "2025-12-25T21:22:14.889443"
      },
      "task_intent": {
        "title": "001-complete-guidelines-rag-pdf-import",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T01:36:13.091479",
  "last_updated": "2025-12-25T01:36:13.104402"
}