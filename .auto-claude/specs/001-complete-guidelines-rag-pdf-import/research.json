{
  "integrations_researched": [
    {
      "name": "LangChain Community",
      "type": "library",
      "verified_package": {
        "name": "langchain-community",
        "install_command": "pip install langchain-community",
        "version": ">=0.0.10",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from langchain_community.document_loaders import PyPDFLoader"
        ],
        "initialization": "loader = PyPDFLoader(file_path)\ndocs = loader.load()",
        "key_functions": [
          "PyPDFLoader(file_path).load() - Returns list of Document objects, one per page",
          "Document.page_content - The text content",
          "Document.metadata - Contains source path and page number"
        ],
        "verified_against": "Context7 MCP: /websites/langchain_oss_python_langchain"
      },
      "configuration": {
        "env_vars": [],
        "dependencies": ["pypdf"]
      },
      "gotchas": [
        "PyPDFLoader creates one Document object per page",
        "Page numbers start at 0 in metadata",
        "Metadata structure: {'source': 'filepath', 'page': 0}"
      ],
      "research_sources": [
        "Context7 MCP: /websites/langchain_oss_python_langchain",
        "https://docs.langchain.com/oss/python/langchain/knowledge-base"
      ]
    },
    {
      "name": "LangChain Text Splitters",
      "type": "library",
      "verified_package": {
        "name": "langchain-text-splitters",
        "install_command": "pip install langchain-text-splitters",
        "version": "latest",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from langchain_text_splitters import RecursiveCharacterTextSplitter"
        ],
        "initialization": "text_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=1000,\n    chunk_overlap=200,\n    separators=[\"\\n\\n\", \"\\n\", \" \", \"\"],\n    add_start_index=True\n)",
        "key_functions": [
          "split_documents(docs) - Splits Document objects into smaller chunks",
          "split_text(text) - Splits raw text strings"
        ],
        "verified_against": "Context7 MCP: /websites/langchain_oss_python_langchain"
      },
      "configuration": {
        "recommended_settings": {
          "chunk_size": "1000 characters (for medical documents, consider preserving context)",
          "chunk_overlap": "200 characters (20% overlap recommended)",
          "separators": "[\"\\n\\n\", \"\\n\", \" \", \"\"] - Hierarchical splitting",
          "add_start_index": "true - Tracks position in original document"
        }
      },
      "gotchas": [
        "RecursiveCharacterTextSplitter tries separators in order - starts with paragraphs, then sentences",
        "Chunk overlap ensures context preservation across boundaries",
        "add_start_index=True adds 'start_index' to metadata for tracking position",
        "Chunk size is character-based, not token-based",
        "Medical documents may need larger chunks to preserve clinical context"
      ],
      "research_sources": [
        "Context7 MCP: /websites/langchain_oss_python_langchain",
        "Code example from existing codebase: backend/data_processing/loaders/guidelines_loader.py"
      ]
    },
    {
      "name": "LangChain OpenAI",
      "type": "library",
      "verified_package": {
        "name": "langchain-openai",
        "install_command": "pip install langchain-openai",
        "version": ">=0.0.5",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from langchain_openai import OpenAIEmbeddings"
        ],
        "initialization": "embeddings = OpenAIEmbeddings(\n    model=\"text-embedding-3-small\",\n    api_key=settings.OPENAI_API_KEY\n)",
        "key_functions": [
          "embed_documents(texts) - Generate embeddings for list of texts",
          "embed_query(text) - Generate embedding for single query text"
        ],
        "verified_against": "Context7 MCP + existing codebase"
      },
      "configuration": {
        "env_vars": ["OPENAI_API_KEY"],
        "model_options": {
          "text-embedding-3-small": "1536 dimensions, cost-effective, good performance",
          "text-embedding-3-large": "3072 dimensions (customizable), higher quality",
          "text-embedding-ada-002": "1536 dimensions, legacy model"
        }
      },
      "gotchas": [
        "text-embedding-3-small is recommended for cost vs performance",
        "Batch embeddings are more efficient than individual calls",
        "API rate limits apply - handle with batching",
        "Existing code uses text-embedding-3-small model"
      ],
      "research_sources": [
        "Context7 MCP: /openai/openai-python",
        "Existing implementation: backend/data_processing/loaders/guidelines_loader.py"
      ]
    },
    {
      "name": "pdfplumber",
      "type": "library",
      "verified_package": {
        "name": "pdfplumber",
        "install_command": "pip install pdfplumber",
        "version": ">=0.10.3",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "import pdfplumber"
        ],
        "initialization": "with pdfplumber.open(pdf_path) as pdf:\n    page = pdf.pages[0]",
        "key_functions": [
          "page.extract_text() - Simple text extraction",
          "page.extract_text(layout=True) - Layout-preserving extraction",
          "page.extract_words() - Extract words with bounding boxes",
          "page.extract_tables() - Extract tabular data",
          "page.within_bbox((x0, top, x1, bottom)) - Extract from specific region"
        ],
        "verified_against": "Context7 MCP: /jsvine/pdfplumber"
      },
      "configuration": {
        "extraction_options": {
          "x_tolerance": "Horizontal space tolerance (default: 3)",
          "y_tolerance": "Vertical space tolerance (default: 3)",
          "layout": "Preserve layout (default: False)",
          "layout_mode_space_vertically": "Include vertical whitespace (default: True)"
        }
      },
      "gotchas": [
        "Better for complex PDFs with tables and layout preservation than pypdf",
        "extract_text(layout=True) preserves spatial layout but may include extra whitespace",
        "Can handle scanned PDFs if text layer exists (no OCR built-in)",
        "Good for medical guidelines with structured tables",
        "Page indexing starts at 0",
        "Use within_bbox() to extract specific regions like headers/footers"
      ],
      "research_sources": [
        "Context7 MCP: /jsvine/pdfplumber",
        "https://github.com/jsvine/pdfplumber"
      ]
    },
    {
      "name": "pypdf",
      "type": "library",
      "verified_package": {
        "name": "pypdf",
        "install_command": "pip install pypdf",
        "version": ">=3.17.4",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from pypdf import PdfReader"
        ],
        "initialization": "reader = PdfReader(pdf_path)\npage = reader.pages[0]",
        "key_functions": [
          "page.extract_text() - Basic text extraction",
          "page.extract_text(orientations=0) - Extract specific orientation",
          "page.extract_text(extraction_mode='layout') - Layout-preserving mode"
        ],
        "verified_against": "Context7 MCP: /py-pdf/pypdf"
      },
      "configuration": {
        "extraction_modes": {
          "plain": "Simple text extraction (default)",
          "layout": "Preserve spatial layout"
        }
      },
      "gotchas": [
        "Used by LangChain's PyPDFLoader internally",
        "Simpler and faster than pdfplumber for basic text extraction",
        "May not handle complex layouts as well as pdfplumber",
        "Good for straightforward PDF documents",
        "Less feature-rich than pdfplumber for table extraction"
      ],
      "research_sources": [
        "Context7 MCP: /py-pdf/pypdf",
        "https://github.com/py-pdf/pypdf"
      ]
    },
    {
      "name": "FastAPI",
      "type": "library",
      "verified_package": {
        "name": "fastapi",
        "install_command": "pip install fastapi",
        "version": ">=0.110.0",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from fastapi import FastAPI, File, UploadFile, BackgroundTasks",
          "from typing import Annotated"
        ],
        "initialization": "app = FastAPI()",
        "key_functions": [
          "@app.post('/upload') with file: UploadFile = File(...)",
          "await file.read() - Read file content",
          "file.filename, file.content_type - File metadata",
          "background_tasks.add_task(func) - Background processing"
        ],
        "verified_against": "Context7 MCP: /fastapi/fastapi"
      },
      "configuration": {
        "file_upload_patterns": {
          "single_file": "file: UploadFile = File(...)",
          "multiple_files": "files: list[UploadFile] = File(...)",
          "with_form_data": "file: UploadFile = File(...), description: str = Form()"
        }
      },
      "gotchas": [
        "UploadFile is better for large files (streaming) vs bytes (in-memory)",
        "Use BackgroundTasks for long-running operations like PDF processing",
        "File validation should check .filename.endswith('.pdf')",
        "Content is async - use await file.read()",
        "Save file before adding to background tasks (file stream may close)",
        "Existing endpoint at /upload/guideline already implements this pattern"
      ],
      "research_sources": [
        "Context7 MCP: /fastapi/fastapi",
        "Existing implementation: backend/app/api/v1/endpoints/admin.py"
      ]
    },
    {
      "name": "Supabase Python",
      "type": "library",
      "verified_package": {
        "name": "supabase",
        "install_command": "pip install supabase",
        "version": ">=2.3.0",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from supabase import create_client, Client"
        ],
        "initialization": "supabase: Client = create_client(url, key)",
        "key_functions": [
          "supabase.table('table_name').insert(data).execute()",
          "supabase.table('table_name').select('*').execute()",
          "supabase.table('table_name').delete().filter('column', 'eq', value).execute()",
          "supabase.table('table_name').upsert(data).execute()"
        ],
        "verified_against": "Context7 MCP: /supabase/supabase-py"
      },
      "configuration": {
        "env_vars": [
          "SUPABASE_URL",
          "SUPABASE_KEY"
        ],
        "vector_storage": {
          "table_structure": "guidelines table with (id, title, organization, publication_year, is_czech, content, metadata, embedding)",
          "embedding_column": "vector type for pgvector similarity search",
          "metadata_format": "JSONB column storing {source, page, ...}"
        }
      },
      "gotchas": [
        "Delete existing chunks before re-inserting to avoid duplicates",
        "Use .filter('metadata->>source', 'eq', filename) for JSONB queries",
        "Batch inserts (50-100 records) are more efficient than single inserts",
        "Vector embeddings must match the dimension configured in pgvector",
        "Existing implementation uses idempotent pattern: delete then insert",
        "The guidelines table schema is defined in 008_guidelines.sql migration"
      ],
      "research_sources": [
        "Context7 MCP: /supabase/supabase-py",
        "Existing implementation: backend/data_processing/loaders/guidelines_loader.py",
        "Existing database client: backend/app/core/database.py"
      ]
    },
    {
      "name": "OpenAI Python SDK",
      "type": "library",
      "verified_package": {
        "name": "openai",
        "install_command": "pip install openai",
        "version": ">=1.12.0",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from openai import OpenAI"
        ],
        "initialization": "client = OpenAI(api_key=api_key)",
        "key_functions": [
          "client.embeddings.create(model='text-embedding-3-small', input=texts)",
          "response.data[i].embedding - Access embedding vectors"
        ],
        "verified_against": "Context7 MCP: /openai/openai-python"
      },
      "configuration": {
        "env_vars": ["OPENAI_API_KEY"],
        "models": {
          "text-embedding-3-small": {
            "dimensions": 1536,
            "use_case": "Cost-effective, good for most applications",
            "cost": "Lower cost per token"
          },
          "text-embedding-3-large": {
            "dimensions": "3072 (customizable with dimensions parameter)",
            "use_case": "Higher quality embeddings",
            "cost": "Higher cost per token"
          }
        }
      },
      "gotchas": [
        "Batch multiple texts in single API call for efficiency",
        "API rate limits apply - implement retry logic",
        "Embeddings are normalized (unit length)",
        "Dimensions must match vector database schema",
        "LangChain wraps this - prefer LangChain's OpenAIEmbeddings for integration"
      ],
      "research_sources": [
        "Context7 MCP: /openai/openai-python",
        "Existing implementation: backend/data_processing/embeddings/embedding_generator.py"
      ]
    },
    {
      "name": "pytesseract",
      "type": "library",
      "verified_package": {
        "name": "pytesseract",
        "install_command": "pip install pytesseract",
        "version": ">=0.3.10",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "import pytesseract"
        ],
        "initialization": "N/A - Direct function calls",
        "key_functions": [
          "pytesseract.image_to_string(image) - OCR on images"
        ],
        "verified_against": "PyPI package listing"
      },
      "configuration": {
        "dependencies": ["Tesseract OCR system binary must be installed separately"],
        "env_vars": ["TESSERACT_CMD (optional path to tesseract binary)"]
      },
      "gotchas": [
        "Requires external Tesseract OCR installation (not Python-only)",
        "Needed only for scanned PDFs without text layer",
        "May not be needed if medical guidelines are born-digital PDFs",
        "Performance overhead for OCR processing",
        "Listed in requirements.txt but may be optional for this task"
      ],
      "research_sources": [
        "Existing requirement: backend/requirements.txt",
        "PyPI: https://pypi.org/project/pytesseract/"
      ]
    }
  ],
  "unverified_claims": [],
  "recommendations": [
    "Use LangChain's PyPDFLoader as primary PDF loader - it's already integrated and handles one-doc-per-page",
    "RecursiveCharacterTextSplitter with chunk_size=1000, overlap=200 is good starting point - may need tuning for medical context",
    "Consider larger chunks (1500-2000) for medical guidelines to preserve clinical context and citations",
    "pdfplumber is available but not needed unless complex table extraction is required",
    "Existing GuidelinesLoader implementation is solid foundation - already handles batching, metadata, and idempotent uploads",
    "text-embedding-3-small is cost-effective and sufficient for Czech medical text",
    "Batch embeddings in groups of 50-100 to optimize API usage and avoid rate limits",
    "Ensure metadata preserves both document name AND page number for proper citations",
    "Test with actual Czech medical guideline PDFs to validate format compatibility",
    "Background task processing is already implemented - good for handling large PDFs",
    "Consider adding progress tracking/logging for multi-page PDF processing",
    "Validate that pgvector index exists on embeddings column for fast similarity search"
  ],
  "multi_format_support_strategy": {
    "approach": "Test-and-adapt pattern",
    "rationale": "Medical guidelines may come in various PDF formats (scanned, digital, mixed)",
    "detection_logic": [
      "Try PyPDFLoader first (handles most born-digital PDFs)",
      "If text extraction is empty or minimal, try pdfplumber with layout=True",
      "If still empty, may be scanned PDF - would need OCR (pytesseract)",
      "Log extraction method used for monitoring"
    ],
    "formats_to_test": [
      "Born-digital PDF with standard text layer",
      "PDF with complex tables/layout",
      "Scanned PDF (if OCR is needed)"
    ]
  },
  "context7_libraries_used": [
    "/websites/langchain_oss_python_langchain",
    "/jsvine/pdfplumber",
    "/py-pdf/pypdf",
    "/fastapi/fastapi",
    "/supabase/supabase-py",
    "/openai/openai-python"
  ],
  "created_at": "2024-12-24T10:30:00Z"
}
